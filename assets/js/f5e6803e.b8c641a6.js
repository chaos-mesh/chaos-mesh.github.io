"use strict";(self.webpackChunkchaos_mesh_website=self.webpackChunkchaos_mesh_website||[]).push([[9482],{3905:function(e,t,a){a.d(t,{Zo:function(){return h},kt:function(){return d}});var n=a(7294);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,o=function(e,t){if(null==e)return{};var a,n,o={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var i=n.createContext({}),c=function(e){var t=n.useContext(i),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},h=function(e){var t=c(e.components);return n.createElement(i.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,o=e.mdxType,r=e.originalType,i=e.parentName,h=s(e,["components","mdxType","originalType","parentName"]),m=c(a),d=o,u=m["".concat(i,".").concat(d)]||m[d]||p[d]||r;return a?n.createElement(u,l(l({ref:t},h),{},{components:a})):n.createElement(u,l({ref:t},h))}));function d(e,t){var a=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=a.length,l=new Array(r);l[0]=m;var s={};for(var i in t)hasOwnProperty.call(t,i)&&(s[i]=t[i]);s.originalType=e,s.mdxType="string"==typeof e?e:o,l[1]=s;for(var c=2;c<r;c++)l[c]=a[c];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},9907:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return l},contentTitle:function(){return s},metadata:function(){return i},toc:function(){return c},default:function(){return p}});var n=a(2122),o=a(9756),r=(a(7294),a(3905)),l={id:"develop_a_new_chaos",title:"Develop a New Chaos",sidebar_label:"Develop a New Chaos"},s=void 0,i={unversionedId:"development_guides/develop_a_new_chaos",id:"version-1.2.3/development_guides/develop_a_new_chaos",isDocsHomePage:!1,title:"Develop a New Chaos",description:'After preparing the development environment, let\'s develop a new type of chaos, HelloWorldChaos, which only prints a "Hello World!" message to the log. Generally, to add a new chaos type for Chaos Mesh, you need to take the following steps:',source:"@site/versioned_docs/version-1.2.3/development_guides/dev_hello_world.md",sourceDirName:"development_guides",slug:"/development_guides/develop_a_new_chaos",permalink:"/docs/development_guides/develop_a_new_chaos",editUrl:"https://github.com/chaos-mesh/website/edit/master/versioned_docs/version-1.2.3/development_guides/dev_hello_world.md",version:"1.2.3",frontMatter:{id:"develop_a_new_chaos",title:"Develop a New Chaos",sidebar_label:"Develop a New Chaos"},sidebar:"version-1.2.3/docs",previous:{title:"Set up the development environment",permalink:"/docs/development_guides/set_up_the_development_environment"},next:{title:"Add Facilities to Chaos Daemon",permalink:"/docs/development_guides/add_facilities_to_chaos_daemon"}},c=[{value:"Define the schema type",id:"define-the-schema-type",children:[]},{value:"Register the CRD",id:"register-the-crd",children:[]},{value:"Register the handler for this chaos object",id:"register-the-handler-for-this-chaos-object",children:[]},{value:"Make the Docker image",id:"make-the-docker-image",children:[]},{value:"Run chaos",id:"run-chaos",children:[]},{value:"Next steps",id:"next-steps",children:[]}],h={toc:c};function p(e){var t=e.components,a=(0,o.Z)(e,["components"]);return(0,r.kt)("wrapper",(0,n.Z)({},h,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"After ",(0,r.kt)("a",{parentName:"p",href:"/docs/development_guides/set_up_the_development_environment"},"preparing the development environment"),', let\'s develop a new type of chaos, HelloWorldChaos, which only prints a "Hello World!" message to the log. Generally, to add a new chaos type for Chaos Mesh, you need to take the following steps:'),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("a",{parentName:"li",href:"#define-the-schema-type"},"Define the schema type")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("a",{parentName:"li",href:"#register-the-crd"},"Register the CRD")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("a",{parentName:"li",href:"#register-the-handler-for-this-chaos-object"},"Register the handler for this chaos object")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("a",{parentName:"li",href:"#make-the-docker-image"},"Make the Docker image")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("a",{parentName:"li",href:"#run-chaos"},"Run chaos"))),(0,r.kt)("h2",{id:"define-the-schema-type"},"Define the schema type"),(0,r.kt)("p",null,"To define the schema type for the new chaos object, add ",(0,r.kt)("inlineCode",{parentName:"p"},"helloworldchaos_types.go")," in the api directory ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/chaos-mesh/chaos-mesh/tree/master/api/v1alpha1"},(0,r.kt)("inlineCode",{parentName:"a"},"api/v1alpha1"))," and fill it with the following content:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'package v1alpha1\n\nimport (\n    metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"\n)\n\n// +kubebuilder:object:root=true\n// +chaos-mesh:base\n\n// HelloWorldChaos is the Schema for the helloworldchaos API\ntype HelloWorldChaos struct {\n    metav1.TypeMeta   `json:",inline"`\n    metav1.ObjectMeta `json:"metadata,omitempty"`\n\n    Spec   HelloWorldChaosSpec   `json:"spec"`\n    Status HelloWorldChaosStatus `json:"status,omitempty"`\n}\n\n// HelloWorldChaosSpec is the content of the specification for a HelloWorldChaos\ntype HelloWorldChaosSpec struct {\n    // Duration represents the duration of the chaos action\n    // +optional\n    Duration *string `json:"duration,omitempty"`\n\n    // Scheduler defines some schedule rules to control the running time of the chaos experiment about time.\n    // +optional\n    Scheduler *SchedulerSpec `json:"scheduler,omitempty"`\n}\n\n// HelloWorldChaosStatus represents the status of a HelloWorldChaos\ntype HelloWorldChaosStatus struct {\n    ChaosStatus `json:",inline"`\n}\n')),(0,r.kt)("p",null,"With this file added, the HelloWorldChaos schema type is defined. The structure of it can be described as the YAML file below:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: chaos-mesh.org/v1alpha1\nkind: HelloWorldChaos\nmetadata:\n  name: <name-of-this-resource>\n  namespace: <ns-of-this-resource>\nspec:\n  duration: <duration-of-every-action>\n  scheduler:\n    cron: <the-cron-job-definition-of-this-chaos>\nstatus:\n  phase: <phase-of-this-resource>\n  ...\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"make generate")," will generate boilerplate functions for it, which is needed to integrate the resource in the Chaos Mesh."),(0,r.kt)("h2",{id:"register-the-crd"},"Register the CRD"),(0,r.kt)("p",null,"The HelloWorldChaos object is a custom resource object in Kubernetes. This means you need to register the corresponding CRD in the Kubernetes API. Run ",(0,r.kt)("inlineCode",{parentName:"p"},"make yaml"),", then the CRD will be generated in ",(0,r.kt)("inlineCode",{parentName:"p"},"config/crd/bases/chaos-mesh.org_helloworldchaos.yaml"),". In order to combine all these YAML file into ",(0,r.kt)("inlineCode",{parentName:"p"},"manifests/crd.yaml"),", modify ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/chaos-mesh/chaos-mesh/blob/master/config/crd/kustomization.yaml"},(0,r.kt)("inlineCode",{parentName:"a"},"kustomization.yaml"))," by adding the corresponding line as shown below:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"resources:\n  - bases/chaos-mesh.org_podchaos.yaml\n  - bases/chaos-mesh.org_networkchaos.yaml\n  - bases/chaos-mesh.org_iochaos.yaml\n  - bases/chaos-mesh.org_helloworldchaos.yaml # this is the new line\n")),(0,r.kt)("p",null,"Run ",(0,r.kt)("inlineCode",{parentName:"p"},"make yaml")," again, and the definition of HelloWorldChaos will show in ",(0,r.kt)("inlineCode",{parentName:"p"},"manifests/crd.yaml"),". You can check it through ",(0,r.kt)("inlineCode",{parentName:"p"},"git diff")),(0,r.kt)("h2",{id:"register-the-handler-for-this-chaos-object"},"Register the handler for this chaos object"),(0,r.kt)("p",null,"Create file ",(0,r.kt)("inlineCode",{parentName:"p"},"controllers/helloworldchaos/types.go")," and fill it with following codes:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'package helloworldchaos\n\nimport (\n    "context"\n\n    "k8s.io/apimachinery/pkg/runtime"\n    ctrl "sigs.k8s.io/controller-runtime"\n\n    "github.com/chaos-mesh/chaos-mesh/api/v1alpha1"\n    "github.com/chaos-mesh/chaos-mesh/pkg/router"\n    ctx "github.com/chaos-mesh/chaos-mesh/pkg/router/context"\n    end "github.com/chaos-mesh/chaos-mesh/pkg/router/endpoint"\n)\n\ntype endpoint struct {\n    ctx.Context\n}\n\nfunc (e *endpoint) Apply(ctx context.Context, req ctrl.Request, chaos v1alpha1.InnerObject) error {\n    e.Log.Info("Hello World!")\n    return nil\n}\n\nfunc (e *endpoint) Recover(ctx context.Context, req ctrl.Request, chaos v1alpha1.InnerObject) error {\n    return nil\n}\n\nfunc (e *endpoint) Object() v1alpha1.InnerObject {\n    return &v1alpha1.HelloWorldChaos{}\n}\n\nfunc init() {\n    router.Register("helloworldchaos", &v1alpha1.HelloWorldChaos{}, func(obj runtime.Object) bool {\n        return true\n    }, func(ctx ctx.Context) end.Endpoint {\n        return &endpoint{\n            Context: ctx,\n        }\n    })\n}\n')),(0,r.kt)("p",null,"We should also import ",(0,r.kt)("inlineCode",{parentName:"p"},"github.com/chaos-mesh/chaos-mesh/controllers/helloworldchaos")," in the ",(0,r.kt)("inlineCode",{parentName:"p"},"cmd/controller-manager/main.go"),", then it will register on the route table when the controller starts up."),(0,r.kt)("h2",{id:"make-the-docker-image"},"Make the Docker image"),(0,r.kt)("p",null,"Having the object successfully added, you can make a Docker image:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"make\n")),(0,r.kt)("p",null,"Then push it to your registry:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"make docker-push\n")),(0,r.kt)("p",null,"If your Kubernetes cluster is deployed by Kind, you need to load images to Kind:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"kind load docker-image localhost:5000/pingcap/chaos-mesh:latest\nkind load docker-image localhost:5000/pingcap/chaos-daemon:latest\nkind load docker-image localhost:5000/pingcap/chaos-dashboard:latest\n")),(0,r.kt)("h2",{id:"run-chaos"},"Run chaos"),(0,r.kt)("p",null,"You are almost there. In this step, you will pull the image and apply it for testing."),(0,r.kt)("p",null,"Before you pull any image for Chaos Mesh (using ",(0,r.kt)("inlineCode",{parentName:"p"},"helm install")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"helm upgrade"),"), modify ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/chaos-mesh/chaos-mesh/blob/master/helm/chaos-mesh/values.yaml"},(0,r.kt)("inlineCode",{parentName:"a"},"values.yaml"))," of the helm template to replace the default image with what you just pushed to your local registry."),(0,r.kt)("p",null,"In this case, the template uses ",(0,r.kt)("inlineCode",{parentName:"p"},"pingcap/chaos-mesh:latest")," as the default target registry, so you need to replace it with the environment variable ",(0,r.kt)("inlineCode",{parentName:"p"},"DOCKER_REGISTRY"),"'s value(default ",(0,r.kt)("inlineCode",{parentName:"p"},"localhost:5000"),"), as shown below:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"clusterScoped: true\n\n# Also see clusterScoped and controllerManager.serviceAccount\nrbac:\n  create: true\n\ncontrollerManager:\n  serviceAccount: chaos-controller-manager\n  ...\n  image: localhost:5000/pingcap/chaos-mesh:latest\n  ...\nchaosDaemon:\n  image: localhost:5000/pingcap/chaos-daemon:latest\n  ...\ndashboard:\n  image: localhost:5000/pingcap/chaos-dashboard:latest\n  ...\n")),(0,r.kt)("p",null,"Now take the following steps to run chaos:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Create namespace ",(0,r.kt)("inlineCode",{parentName:"p"},"chaos-testing")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl create namespace chaos-testing\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Get the related custom resource type for Chaos Mesh:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl apply -f manifests/\n")),(0,r.kt)("p",{parentName:"li"},"You can see CRD ",(0,r.kt)("inlineCode",{parentName:"p"},"helloworldchaos")," is created:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-log"},"customresourcedefinition.apiextensions.k8s.io/helloworldchaos.chaos-mesh.org created\n")),(0,r.kt)("p",{parentName:"li"},"Now you can get the CRD using the command below:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl get crd helloworldchaos.chaos-mesh.org\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Install Chaos Mesh:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"For helm 3.X"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"helm install chaos-mesh helm/chaos-mesh --namespace=chaos-testing --set chaosDaemon.runtime=containerd --set chaosDaemon.socketPath=/run/containerd/containerd.sock\n"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"For helm 2.X"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"helm install helm/chaos-mesh --name=chaos-mesh --namespace=chaos-testing --set chaosDaemon.runtime=containerd --set chaosDaemon.socketPath=/run/containerd/containerd.sock\n")))),(0,r.kt)("p",{parentName:"li"},"To verify your installation, get pods from the ",(0,r.kt)("inlineCode",{parentName:"p"},"chaos-testing")," namespace:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl get pods --namespace chaos-testing -l app.kubernetes.io/instance=chaos-mesh\n")),(0,r.kt)("blockquote",{parentName:"li"},(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Note:")),(0,r.kt)("p",{parentName:"blockquote"},"Arguments ",(0,r.kt)("inlineCode",{parentName:"p"},"--set chaosDaemon.runtime=containerd --set chaosDaemon.socketPath=/run/containerd/containerd.sock")," are used to to support network chaos on kind."))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Create ",(0,r.kt)("inlineCode",{parentName:"p"},"chaos.yaml")," in any location with the lines below:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: chaos-mesh.org/v1alpha1\nkind: HelloWorldChaos\nmetadata:\n  name: hello-world\n  namespace: chaos-testing\nspec: {}\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Apply the chaos:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl apply -f /path/to/chaos.yaml\n")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl get HelloWorldChaos -n chaos-testing\n")),(0,r.kt)("p",{parentName:"li"},"Now you should be able to check the ",(0,r.kt)("inlineCode",{parentName:"p"},"Hello World!")," result in the log of of ",(0,r.kt)("inlineCode",{parentName:"p"},"chaos-controller-manager"),":"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl logs chaos-controller-manager-{pod-post-fix} -n chaos-testing\n")),(0,r.kt)("p",{parentName:"li"},"The log is as follows:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-log"},'2020-09-07T09:21:29.301Z        INFO    controllers.HelloWorldChaos     Hello World!    {"reconciler": "helloworldchaos"}\n2020-09-07T09:21:29.308Z        DEBUG   controller-runtime.controller   Successfully Reconciled {"controller": "helloworldchaos", "request": "chaos-testing/hello-world"}\n')),(0,r.kt)("blockquote",{parentName:"li"},(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Note:")),(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("inlineCode",{parentName:"p"},"{pod-post-fix}")," is a random string generated by Kubernetes. You can check it by executing ",(0,r.kt)("inlineCode",{parentName:"p"},"kubectl get pod -n chaos-testing"),".")))),(0,r.kt)("h2",{id:"next-steps"},"Next steps"),(0,r.kt)("p",null,"Congratulations! You have just added a chaos type for Chaos Mesh successfully. Let us know if you run into any issues during the process. If you feel like doing other types of contributions, refer to ",(0,r.kt)("a",{parentName:"p",href:"/docs/development_guides/add_facilities_to_chaos_daemon"},"Add facilities to chaos daemon"),"."))}p.isMDXComponent=!0}}]);