"use strict";(self.webpackChunkchaos_mesh_website=self.webpackChunkchaos_mesh_website||[]).push([[5522],{22960:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>r,toc:()=>h});var n=s(86070),i=s(6383);const a={slug:"/develop-a-daily-reporting-system",title:"How to Develop a Daily Reporting System to Track Chaos Testing Results",authors:"leili",image:"/img/blog/chaos-mesh-digitalchina-banner.png",tags:["Chaos Mesh","Chaos Engineering","Use Cases"]},o=void 0,r={permalink:"/zh/blog/develop-a-daily-reporting-system",editUrl:"https://github.com/chaos-mesh/website/edit/master/blog/2022-01-11-develop-a-daily-reporting-system.md",source:"@site/blog/2022-01-11-develop-a-daily-reporting-system.md",title:"How to Develop a Daily Reporting System to Track Chaos Testing Results",description:"How to Develop a Daily Reporting System to Track Chaos Testing Results",date:"2022-01-11T00:00:00.000Z",tags:[{inline:!0,label:"Chaos Mesh",permalink:"/zh/blog/tags/chaos-mesh"},{inline:!0,label:"Chaos Engineering",permalink:"/zh/blog/tags/chaos-engineering"},{inline:!0,label:"Use Cases",permalink:"/zh/blog/tags/use-cases"}],readingTime:6.995,hasTruncateMarker:!0,authors:[{name:"Lei Li",title:"Senior software engineer at Digital China",url:"https://github.com/lileiaab",imageURL:"https://avatars.githubusercontent.com/u/88825087?v=4",key:"leili",page:null}],frontMatter:{slug:"/develop-a-daily-reporting-system",title:"How to Develop a Daily Reporting System to Track Chaos Testing Results",authors:"leili",image:"/img/blog/chaos-mesh-digitalchina-banner.png",tags:["Chaos Mesh","Chaos Engineering","Use Cases"]},unlisted:!1,prevItem:{title:"Experience as an LFX Mentee for Chaos Mesh",permalink:"/zh/blog/experience-as-a-chaos-mesh-lfx-mentee"},nextItem:{title:"Share your #ChaosMeshStory!",permalink:"/zh/blog/share-your-chaos-mesh-story"}},l={authorsImageUrls:[void 0]},h=[{value:"Deploy Chaos Mesh on Kubernetes",id:"deploy-chaos-mesh-on-kubernetes",level:2},{value:"Deploy TiDB",id:"deploy-tidb",level:2},{value:"Run a chaos experiment",id:"run-a-chaos-experiment",level:2},{value:"Generate daily report",id:"generate-daily-report",level:2},{value:"Collect logs",id:"collect-logs",level:3},{value:"Filter errors and warnings",id:"filter-errors-and-warnings",level:3},{value:"Draw a plot",id:"draw-a-plot",level:3},{value:"Generate the report in PDF",id:"generate-the-report-in-pdf",level:3},{value:"Build a web application for daily reporting",id:"build-a-web-application-for-daily-reporting",level:2},{value:"Summary",id:"summary",level:2}];function c(e){const t={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"How to Develop a Daily Reporting System to Track Chaos Testing Results",src:s(14706).A+"",width:"1501",height:"501"})}),"\n",(0,n.jsx)(t.p,{children:"Chaos Mesh is a cloud-native chaos engineering platform that orchestrates chaos experiments on Kubernetes environments. It allows you to test the resilience of your system by simulating problems such as network faults, file system faults, and Pod faults. After each chaos experiment, you can review the testing results by checking the logs. But this is neither direct nor efficient. Therefore, I decided to develop a daily reporting system that would automatically analyze logs and generate reports. This way, it\u2019s easy to examine the logs and identify the issues."}),"\n",(0,n.jsx)(t.p,{children:"In this article, I will give you some insights about how to build a daily reporting system, as well as the problems I encountered during the process and how I fixed them."}),"\n",(0,n.jsx)(t.h2,{id:"deploy-chaos-mesh-on-kubernetes",children:"Deploy Chaos Mesh on Kubernetes"}),"\n",(0,n.jsx)(t.p,{children:"Chaos Mesh is designed for Kubernetes, which is one of the important reasons why it can allow users to inject faults into the file system, Pod, or network for specific applications."}),"\n",(0,n.jsxs)(t.p,{children:["In earlier documents, Chaos Mesh offered two ways to quickly deploy a virtual Kubernetes cluster on your machine: ",(0,n.jsx)(t.a,{href:"https://github.com/kubernetes-sigs/kind",children:"kind"})," and ",(0,n.jsx)(t.a,{href:"https://minikube.sigs.k8s.io/docs/start/",children:"minikube"}),". Generally, it only takes a one-line command to deploy a Kubernetes cluster as well as install Chaos Mesh. But there are some problems:"]}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Starting Kubernetes clusters locally affects network-related fault types."}),"\n",(0,n.jsx)(t.li,{children:"Users on the Chinese mainland might experience an extremely slow process to pull the Docker image or even a timeout."}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["If you use the provided script to deploy a Kubernetes cluster using kind, all Kubernetes nodes are virtual machines (VM). This adds difficulty when you pull the image offline. To address this issue, you can deploy the Kubernetes cluster on multiple physical machines instead, with each physical machine acting as a worker node. To expedite the image pulling process, you can use the ",(0,n.jsx)(t.code,{children:"docker load"})," command to load the required image in advance. Apart from the two problems above, you can install ",(0,n.jsx)(t.a,{href:"https://kubernetes.io/docs/reference/kubectl/overview/",children:"kubectl"})," and ",(0,n.jsx)(t.a,{href:"https://helm.sh/",children:"Helm"})," by following the documentation."]}),"\n",(0,n.jsxs)(t.p,{children:["Note: For the latest installation and deployment instructions, refer to ",(0,n.jsx)(t.a,{href:"https://chaos-mesh.org/docs/quick-start/",children:"Chaos Mesh Quick Start"}),"."]}),"\n",(0,n.jsx)(t.h2,{id:"deploy-tidb",children:"Deploy TiDB"}),"\n",(0,n.jsxs)(t.p,{children:["The next step is to deploy TiDB on Kubernetes. I used TiDB Operator to streamline the process. For details, check out ",(0,n.jsx)(t.a,{href:"https://docs.pingcap.com/tidb-in-kubernetes/stable/get-started",children:"Get started with TiDB Operator in Kubernetes"}),"."]}),"\n",(0,n.jsx)(t.p,{children:"I\u2019d like to highlight two points in this process:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"First, install Custom Resource Definitions (CRDs) to implement different components of TiDB Operator. Otherwise, you\u2019ll get errors when you try to install TiDB Operator."}),"\n",(0,n.jsxs)(t.li,{children:["Use ",(0,n.jsx)(t.a,{href:"https://longhorn.io/",children:"Longhorn"}),", a distributed block storage system for Kubernetes, to create local persistent volumes (PV) for your Kubernetes cluster. This way, you don\u2019t have to create PVs in advance: whenever a Pod is pulled, a PV is automatically created and mounted."]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"The biggest problem that I encountered was that pulling the image could be extremely slow when deploying the service. If the nodes in your Kubernetes cluster are virtual machines, pull the required images in advance and load them to the Docker of each machine:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-bash",children:"## Pull required images on a machine with a good network connection\ndocker pull pingcap/tikv:latest\ndocker pull pingcap/tidb:latest\ndocker pull pingcap/pd:latest\n\n## Export images and save them to each machine in the Kubernetes cluster\ndocker save -o tikv.tar pingcap/tikv:latest\ndocker save -o tidb.tar pingcap/tidb:latest\ndocker save -o pd.tar pingcap/pd:latest\n\n## Load images to each machine\ndocker load &lt; tikv.tar\ndocker load &lt; tidb.tar\ndocker load &lt; pd.tar\n"})}),"\n",(0,n.jsxs)(t.p,{children:["The above commands allow you to use the TiDB image in the local Docker registry to deploy the latest TiDB cluster, saving you the trouble of pulling the image from the remote repository. The idea also applies to the Chaos Mesh installation as described earlier. If you do not know which images you need to pull, install Chaos Mesh using Helm to trigger the installation process, then use the ",(0,n.jsx)(t.code,{children:"kubectl describe"})," command to verify:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-bash",children:"## Check pods that are deployed in a specific namespace.\nkubectl describe pods -n tidb-test\n"})}),"\n",(0,n.jsx)(t.p,{children:"The mirror pulling process usually takes the longest time to complete. If the Pod is being scheduled to a node, check it later."}),"\n",(0,n.jsx)(t.h2,{id:"run-a-chaos-experiment",children:"Run a chaos experiment"}),"\n",(0,n.jsxs)(t.p,{children:["To run a chaos experiment, you have to define it first through YAML files and use ",(0,n.jsx)(t.code,{children:"kubectl apply"})," to start it. In this example, I created a chaos experiment using PodChaos to simulate a Pod crashing. For detailed instructions, refer to ",(0,n.jsx)(t.a,{href:"https://chaos-mesh.org/docs/run-a-chaos-experiment/",children:"Run a Chaos Experiment"}),"."]}),"\n",(0,n.jsx)(t.h2,{id:"generate-daily-report",children:"Generate daily report"}),"\n",(0,n.jsx)(t.h3,{id:"collect-logs",children:"Collect logs"}),"\n",(0,n.jsxs)(t.p,{children:["Usually, when you run chaos experiments on TiDB clusters, many errors are returned. To collect those error logs, run the ",(0,n.jsx)(t.code,{children:"kubectl logs"})," command:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-bash",children:"kubectl logs &lt;podname> -n tidb-test --since=24h >> tidb.log\n"})}),"\n",(0,n.jsxs)(t.p,{children:["All logs generated in the past 24 hours of the specific Pod in the ",(0,n.jsx)(t.code,{children:"tidb-test"})," namespace will be saved to the ",(0,n.jsx)(t.code,{children:"tidb.log"})," file."]}),"\n",(0,n.jsx)(t.h3,{id:"filter-errors-and-warnings",children:"Filter errors and warnings"}),"\n",(0,n.jsx)(t.p,{children:"In this step, you have to filter error messages and warning messages from logs. There are two options:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Use text processing tools, such as awk. This requires a proficient understanding of Linux/Unix commands."}),"\n",(0,n.jsx)(t.li,{children:"Write a script. If you\u2019re not familiar with Linux/Unix commands, this is the better option."}),"\n"]}),"\n",(0,n.jsx)(t.h3,{id:"draw-a-plot",children:"Draw a plot"}),"\n",(0,n.jsxs)(t.p,{children:["For plotting, I used ",(0,n.jsx)(t.a,{href:"http://www.gnuplot.info/",children:"gnuplot"}),", a Linux command-line graphing utility. In the example below, I imported the pressure measurement results and created a line graph to show how queries per second (QPS) were affected when a specific Pod became unavailable. Since the chaos experiment was executed periodically, the number of QPS exhibited a pattern: it would drop abruptly and then quickly return to normal."]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"QPS line graph",src:s(90769).A+"",width:"678",height:"356"})}),"\n",(0,n.jsx)("p",{class:"caption",children:"QPS line graph"}),"\n",(0,n.jsx)(t.h3,{id:"generate-the-report-in-pdf",children:"Generate the report in PDF"}),"\n",(0,n.jsxs)(t.p,{children:["Currently, there is no available API for generating Chaos Mesh reports or analyzing results. I decided to generate the report in PDF format so it would be readable on different browsers. In my case, I used ",(0,n.jsx)(t.a,{href:"https://github.com/signintech/gopdf",children:"gopdf"}),", a support library that allows users to create PDF files. It also lets me insert images or draw tables, which meets my needs."]}),"\n",(0,n.jsxs)(t.p,{children:["To generate a daily report, I used ",(0,n.jsx)(t.a,{href:"https://www.linux.org/docs/man8/cron.html",children:"crond"}),", a command-line utility that executes cron jobs in the background, to execute the commands early each morning. So, when I start work, there is a daily report waiting for me."]}),"\n",(0,n.jsx)(t.h2,{id:"build-a-web-application-for-daily-reporting",children:"Build a web application for daily reporting"}),"\n",(0,n.jsxs)(t.p,{children:["But I want to make the report more readable and accessible. Isn\u2019t it nicer if you can check reports on a web application? At first, I wanted to add a backend API and track when the report was generated. It sounds applicable but it may be too much work since all I want is to know which report requires further troubleshooting. The exact information is shown in the file name, for example: ",(0,n.jsx)(t.code,{children:"report-2021-07-09-bad.pdf"}),". Thus, the reporting system\u2019s workload and complexity are greatly reduced."]}),"\n",(0,n.jsx)(t.p,{children:"Still, it is necessary to improve the backend interfaces as well as enrich the report content. But for now, a daily, workable reporting system is just fine."}),"\n",(0,n.jsxs)(t.p,{children:["In my case, I used ",(0,n.jsx)(t.a,{href:"https://github.com/vuejs/vue",children:"Vue.js"})," to scaffold the web application using a UI library ",(0,n.jsx)(t.a,{href:"https://www.antdv.com/docs/vue/introduce/",children:"antd"}),". After that, I updated the page content by saving the automatically generated report to the static resources folder ",(0,n.jsx)(t.code,{children:"static"}),". This allows the web application to read the static reports and then render them to the front end page. For details, check out ",(0,n.jsx)(t.a,{href:"https://www.antdv.com/docs/vue/use-with-vue-cli/",children:"Use antd in vue-cli 3"}),"."]}),"\n",(0,n.jsx)(t.p,{children:"Below is an example of a web application that I developed for daily reporting. The red card indicates that I should take a look at the testing report because exceptions are thrown after running chaos experiments."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"Web application for daily reporting",src:s(70924).A+"",width:"1999",height:"580"})}),"\n",(0,n.jsx)("p",{class:"caption",children:"Web application for daily reporting"}),"\n",(0,n.jsxs)(t.p,{children:["Clicking the red card will open the report, as shown below. I used ",(0,n.jsx)(t.a,{href:"https://github.com/mozilla/pdf.js",children:"pdf.js"})," to view the PDF."]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"Daily report in PDF",src:s(54156).A+"",width:"930",height:"841"})}),"\n",(0,n.jsx)("p",{class:"caption",children:"Daily report in PDF"}),"\n",(0,n.jsx)(t.h2,{id:"summary",children:"Summary"}),"\n",(0,n.jsx)(t.p,{children:"Chaos Mesh enables you to simulate faults that most cloud-native applications might encounter. In this article, I created a PodChaos experiment and observed that QPS in the TiDB cluster was affected when the Pod became unavailable. After analyzing the logs, I can enhance the robustness and high availability of the system. I built a web application to generate daily reports for troubleshooting and debugging. You can also customize the reports to meet your own requirements."}),"\n",(0,n.jsxs)(t.p,{children:["Our team is also working on a project to ",(0,n.jsx)(t.a,{href:"https://github.com/DigitalChinaOpenSource/TiDB-for-PostgreSQL",children:"make TiDB compatible with PostgreSQL"}),". If you are interested and want to make contributions, you are welcome to pick an issue and get started."]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsxs)(t.strong,{children:["Originally published at ",(0,n.jsx)(t.em,{children:(0,n.jsx)(t.a,{href:"https://thenewstack.io/develop-a-daily-reporting-system-for-chaos-mesh-to-improve-system-resilience/",children:"The New Stack"})}),"."]})})]})}function d(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}},14706:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/chaos-mesh-digitalchina-banner-c7d6ac176f56621aa799af0e30d06e96.png"},54156:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/daily-report-pdf-8ae60cf1beb170450c7fd87443084175.png"},90769:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/qps-line-graph-10389785bbe639db08850f5d73c47239.png"},70924:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/web-app-for-daily-reporting-3fc7adf871410eb6a52f15ac84c00d5b.png"},6383:(e,t,s)=>{s.d(t,{R:()=>o,x:()=>r});var n=s(30758);const i={},a=n.createContext(i);function o(e){const t=n.useContext(a);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),n.createElement(a.Provider,{value:t},e.children)}}}]);